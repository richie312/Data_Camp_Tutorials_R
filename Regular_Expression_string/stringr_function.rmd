---
title: "Introducing Stringr Package"
output: html_notebook
---

## stringr package
### Putting strings together with stringr

For your first stringr function, we'll look at ``str_c()``, the ``c`` is short for ``concatentate``, a function that works like ``paste()``. It takes vectors of strings as input along with sep and collapse arguments.

There are two key ways ``str_c()`` differs from ``paste()``. First, the default separator is an empty string, ``sep = ""``, as opposed to a space, so it's more like ``paste0()``. This is an example of a stringr function, performing a similar operation to a base function, but using a default that is more likely to be what you want. Remember in your pizza order, you had to set ``sep = ""  ``  multiple times.

The second way ``str_c()`` differs to ``paste()`` is in its handling of missing values. paste() turns missing values into the string "NA", whereas ``str_c()`` propagates missing values. That means combining any strings with a missing value will result in another missing value.

Let's explore this difference using your pizza order from the previous chapter.

```{r, eval = FALSE}
library(stringr)

my_toppings <- c("cheese", NA, NA)
my_toppings_and <- paste(c("", "", "and "), my_toppings, sep = "")

# Print my_toppings_and
print(my_toppings_and)

# Use str_c() instead of paste(): my_toppings_str
my_toppings_str <- str_c(c("", "", "and "), my_toppings)

# Print my_toppings_str
print(my_toppings_str)

# paste() my_toppings_and with collapse = ", "
paste(my_toppings_and, collapse = ", ")

# str_c() my_toppings_str with collapse = ", "
str_c(my_toppings_str,collapse = ", ")

```

## String length

String length
Our next stringr function is ``str_length()```. ``str_length()`` takes a vector of strings as input and returns the number of characters in each string. For example, try finding the number of characters in Batman's name:

``str_length(c("Bruce", "Wayne"))``
This is very similar to the base function ``nchar()`` but you'll see in the exercises ``str_length()`` handles factors in an intuitive way, whereas ``nchar()`` will just return an error.

Historically, ``nchar()`` was even worse, rather than returning an error if you passed it a factor, it would return the number of characters in the numeric encoding of the factor. Thankfully this behavior has been fixed, but it was one of the original motivations behind ``str_length()``.

Take your first look at babynames by asking if girls' names are longer than boys' names.

```{r, eval = FALSE,echo=FALSE, warning= FALSE}

library(stringr)
library(babynames)
library(dplyr)

# Extracting vectors for boys' and girls' names
babynames_2014 <- filter(babynames, year == 2014)
boy_names <- filter(babynames_2014, sex == "M")$name
girl_names <- filter(babynames_2014, sex == "F")$name

# Take a look at a few boy_names
head(boy_names)

# Find the length of all boy_names
boy_length <- str_length(boy_names)

# Take a look at a few lengths

head(boy_length)

# Find the length of all girl_names
girl_length <- str_length(girl_names)

# Find the difference in mean length
mean(girl_length) - mean(boy_length)

# Confirm str_length() works with factors
head(factor(boy_names))
```


## Extracting substrings

The ``str_sub()`` function in stringr extracts parts of strings based on their location. As with all stringr functions, the first argument, string, is a vector of strings. The arguments start and end specify the boundaries of the piece to extract in characters.

For example, ``str_sub(x, 1, 4)`` asks for the substring starting at the first character, up to the fourth character, or in other words the first four characters. Try it with my Batman's name:

``str_sub(c("Bruce", "Wayne"), 1, 4)``

Both start and end can be negative integers, in which case, they count from the end of the string. For example, ``str_sub(x, -4, -1)``, asks for the substring starting at the fourth character from the end, up to the first character from the end, i.e. the last four characters. Again, try it with Batman:

``str_sub(c("Bruce", "Wayne"), -4, -1)``

```{r, eval=FALSE}

# Extract first letter from boy_names
boy_first_letter <- str_sub(boy_names, 1,1)

# Tabulate occurrences of boy_first_letter
table(boy_first_letter)

# Extract the last letter in boy_names, then tabulate
boy_last_letter <- str_sub(boy_names, str_length(boy_names), str_length(boy_names))
table(boy_last_letter)

# Extract the first letter in girl_names, then tabulate
girl_first_letter <- str_sub(girl_names, 1,1)
table(girl_first_letter)

# Extract the last letter in girl_names, then tabulate
girl_last_letter <- str_sub(girl_names, str_length(girl_names), str_length(girl_names))

table(girl_last_letter)

```


## Hunting for matches

### Detecting matches

#### str_detect()

``str_detect()`` is used to answer the question: Does the string contain the pattern? It returns a logical vector of the same length as that of the input vector string, with ``TRUE`` for elements that contain the pattern and ``FALSE`` otherwise.

```{r, eval = FALSE}

# Look for pattern "zz" in boy_names
contains_zz <- str_detect(boy_names,pattern = c("zz"))

# Examine str() of contains_zz
str(contains_zz)
# How many names contain "zz"?
sum(contains_zz)
# Which names contain "zz"?
boy_names[contains_zz]

# Which rows in boy_df have names that contain "zz"?

boy_df[contains_zz, ]

```


## Subsetting strings based on match;  str_subset()

```{r, eval = FALSE}

# Find boy_names that contain "zz"
str_subset(boy_names, pattern = fixed("zz"))

# Find girl_names that contain "zz"
str_subset(girl_names, pattern = fixed("zz"))

# Find girl_names that contain "U"
starts_U <- str_subset(girl_names, pattern = fixed("U"))
starts_U

# Find girl_names that contain "U" and "z"
str_subset(starts_U, pattern = fixed("z"))

```

## Counting Matches

```{r, eval = FALSE}

# Count occurrences of "a" in girl_names
number_as <- str_count(girl_names, pattern = fixed("a"))

# Count occurrences of "A" in girl_names
number_As <- str_count(girl_names, pattern = fixed("A"))

# Histograms of number_as and number_As
hist(number_as)  
hist(number_As)
# Find total "a" + "A"
total_as <- number_as + number_As

# girl_names with more than 4 a's
girl_names[total_as>4]

```


## Splitting strings

A common use for ``str_split()`` is to pull apart raw string data into more useful variables. In this exercise you'll start by pulling apart a date range, something like ``"23.01.2017 - 29.01.2017"``, into separate variables for the start of the range, ``"23.01.2017"``, and the end of the range, ``"29.01.2017"``.

Remember, if the simplify argument is ``FALSE (the default)`` you'll get back a list of the same length as that of the input vector. More commonly, you'll want to pull out the first piece (or second piece etc.) from every element, which is easier if you specify ``simplify = TRUE`` and get a ``matrix as output``. You'll explore both of these output types in this exercise.

```{r, eval = FALSE}

date_ranges <- c("23.01.2017 - 29.01.2017", "30.01.2017 - 06.02.2017")

# Split dates using " - "
split_dates <- str_split(date_ranges, pattern = fixed(" - "))

# Print split_dates
print(split_dates)

# Split dates with n and simplify specified
split_dates_n <-str_split(date_ranges, pattern = fixed(" - "), n = 2, simplify = TRUE)
split_dates_n

# Subset split_dates_n into start_dates and end_dates
start_dates <- split_dates_n[,1]
end_dates <- split_dates_n[,2]
# Split start_dates into day, month and year pieces
str_split(start_dates, pattern = fixed("."), n = 3, simplify = TRUE)

# Split both_names into first_names and last_names
both_names <- c("Box, George", "Cox, David")
both_names_split <- str_split(both_names, pattern =fixed(", "), n = 2, simplify = TRUE)
first_names <- both_names_split[,2]
last_names <- both_names_split[,1]

```

## Some Simple text statistic

```{r, evaal = FALSE}

# Split lines into words
words <- str_split(lines, pattern = fixed(" "))

# Number of words per line

lapply(words, length)

# Number of characters in each word
word_lengths <- lapply(words, str_length)
  
# Average word length per line

lapply(word_lengths, mean)

```

## Relplacing matches in string

### str_replace()

```{r, eval = FALSE}

ids <- c("ID#: 192", "ID#: 118", "ID#: 001")

# Replace "ID#: " with ""
id_nums <- str_replace(ids, pattern = fixed("ID#: "), replace = "")

# Turn id_nums into numbers
id_ints <- as.numeric(id_nums)
  
# Some (fake) phone numbers
phone_numbers <- c("510-555-0123", "541-555-0167")

# Use str_replace() to replace "-" with " "
str_replace(phone_numbers, pattern = fixed("-"), replace = " ")

# Use str_replace_all() to replace "-" with " "
str_replace_all(phone_numbers, pattern = fixed("-"), replace = " ")

# Turn phone numbers into the format xxx.xxx.xxxx
str_replace_all(phone_numbers, pattern = fixed("-"), replace = ".")

# Find the number of nucleotides in each sequence
str_length(genes)

# Find the number of A's occur in each sequence
str_count(genes, fixed("A"))

# Return the sequences that contain "TTTTTT"
str_subset(genes, fixed("TTTTTT"))

# Replace all the "A"s in the sequences with a "_"
str_replace_all(genes, fixed("A"), "_")

```


## Put it all together

```{r, eval = FALSE}
# --- Task 1 ----
# Define some full names
names <- c("Diana Prince", "Clark Kent")

# Split into first and last names
names_split <- str_split(names, fixed(" "), simplify = TRUE)

# Extract the first letter in the first name
abb_first <- str_sub(names_split[, 1], 1, 1)

# Combine the first letter ". " and last name
str_c(abb_first, ". ", names_split[, 2])

# --- Task 2 ----
# Use all names in babynames_2014
all_names <- babynames_2014$name

# Get the last two letters of all_names
last_two_letters <- str_sub(all_names, -2, -1)

# Does the name end in "ee"?
ends_in_ee <- str_detect(last_two_letters, "ee")

# Extract rows and "sex" column
sex <- babynames_2014$sex[ends_in_ee]

# Display result as a table
table(sex)

```



















































































































































































































































































































































































