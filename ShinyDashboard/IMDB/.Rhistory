type = 'response', set='AUC',method = method,n.trees=10000){
## Fit the model
if (method == 'randomForest'){
train$default<- as.factor(train$factor)
model_forest<- algo(formula = default ~ .,
distribution = distribution,
data = train,
n.trees = n.trees,
cv.fold= 3)
## Generate the prediction on the test set
pred_rf<- predict(object = model,
newdata = test,
n.trees = n.trees,
type = type)
## Generate the test set AUCs using the pred
AUC_rf<- auc(actual = test$default, predicted = pred)
}
if ( method != 'randomForest'){
model<- algo(formula = default ~ .,
distribution = distribution,
data = train,
n.trees = n.trees,
cv.fold= 3)
## Generate the prediction on the test set
pred<- predict(object = model,
newdata = test,
n.trees = n.trees,
type = type)
## Generate the test set AUCs using the pred
AUC<- auc(actual = test$default, predicted = pred)
}
if (set == 'AUC',method=='randomForest'){
return(AUC_RF)
else return(AUC)
}
if (set == 'predictions', method == 'randomForest'){
return(pred_RF)
else return (pred)
}
if (set == 'model', method=='randomForest'){
return(model_forest)
else return(model)
}
else
return(NULL)
}
}
model = function(algo =gbm ,distribution = 'bernoulli',
type = 'response', set='AUC',method = method,n.trees=10000){
## Fit the model
if (method == 'randomForest'){
train$default<- as.factor(train$factor)
model_forest<- algo(formula = default ~ .,
distribution = distribution,
data = train,
n.trees = n.trees,
cv.fold= 3)
## Generate the prediction on the test set
pred_rf<- predict(object = model,
newdata = test,
n.trees = n.trees,
type = type)
## Generate the test set AUCs using the pred
AUC_rf<- auc(actual = test$default, predicted = pred)
}
if ( method != 'randomForest'){
model<- algo(formula = default ~ .,
distribution = distribution,
data = train,
n.trees = n.trees,
cv.fold= 3)
## Generate the prediction on the test set
pred<- predict(object = model,
newdata = test,
n.trees = n.trees,
type = type)
## Generate the test set AUCs using the pred
AUC<- auc(actual = test$default, predicted = pred)
}
if (set == 'AUC',method=='randomForest'){
return(AUC_RF)
else {return(AUC)
}
}
if (set == 'predictions', method == 'randomForest'){
return(pred_RF)
else {return (pred)
}
}
if (set == 'model', method=='randomForest'){
return(model_forest)
else {return(model)
}
}
else
return(NULL)
}
}
model = function(algo =gbm ,distribution = 'bernoulli',
type = 'response', set='AUC',method = method,n.trees=10000){
## Fit the model
if (method == 'randomForest'){
train$default<- as.factor(train$factor)
model_forest<- algo(formula = default ~ .,
distribution = distribution,
data = train,
n.trees = n.trees,
cv.fold= 3)
## Generate the prediction on the test set
pred_rf<- predict(object = model,
newdata = test,
n.trees = n.trees,
type = type)
## Generate the test set AUCs using the pred
AUC_rf<- auc(actual = test$default, predicted = pred)
}
if ( method != 'randomForest'){
model<- algo(formula = default ~ .,
distribution = distribution,
data = train,
n.trees = n.trees,
cv.fold= 3)
## Generate the prediction on the test set
pred<- predict(object = model,
newdata = test,
n.trees = n.trees,
type = type)
## Generate the test set AUCs using the pred
AUC<- auc(actual = test$default, predicted = pred)
}
if (set == 'AUC',method=='randomForest'){
return(AUC_RF)
else {return(AUC)
}
}
if (set == 'predictions', method == 'randomForest'){
return(pred_RF)
else {return (pred)
}
}
if (set == 'model', method=='randomForest'){
return(model_forest)
else {return(model)
}
}
else
return(NULL)
}
model = function(algo =gbm ,distribution = 'bernoulli',
type = 'response', set='AUC',method = method,n.trees=10000){
## Fit the model
if (method == 'randomForest'){
train$default<- as.factor(train$factor)
model_forest<- algo(formula = default ~ .,
distribution = distribution,
data = train,
n.trees = n.trees,
cv.fold= 3)
## Generate the prediction on the test set
pred_rf<- predict(object = model,
newdata = test,
n.trees = n.trees,
type = type)
## Generate the test set AUCs using the pred
AUC_rf<- auc(actual = test$default, predicted = pred)
}
if ( method != 'randomForest'){
model<- algo(formula = default ~ .,
distribution = distribution,
data = train,
n.trees = n.trees,
cv.fold= 3)
## Generate the prediction on the test set
pred<- predict(object = model,
newdata = test,
n.trees = n.trees,
type = type)
## Generate the test set AUCs using the pred
AUC<- auc(actual = test$default, predicted = pred)
}
if (set == 'AUC',method=='randomForest'){
return(AUC_RF)}
else return(AUC)
if (set == 'predictions', method == 'randomForest'){
return(pred_RF)}
else return (pred)
if (set == 'model', method=='randomForest'){
return(model_forest)}
else return(model)
else
return(NULL)
}
model = function(algo =gbm ,distribution = 'bernoulli',
type = 'response', set='AUC',method = method,n.trees=10000){
## Fit the model
if (method == 'randomForest'){
train$default<- as.factor(train$factor)
model_forest<- algo(formula = default ~ .,
distribution = distribution,
data = train,
n.trees = n.trees,
cv.fold= 3)
## Generate the prediction on the test set
pred_rf<- predict(object = model,
newdata = test,
n.trees = n.trees,
type = type)
## Generate the test set AUCs using the pred
AUC_rf<- auc(actual = test$default, predicted = pred)
}
if ( method != 'randomForest'){
model<- algo(formula = default ~ .,
distribution = distribution,
data = train,
n.trees = n.trees,
cv.fold= 3)
## Generate the prediction on the test set
pred<- predict(object = model,
newdata = test,
n.trees = n.trees,
type = type)
## Generate the test set AUCs using the pred
AUC<- auc(actual = test$default, predicted = pred)
}
if (set == 'AUC',method=='randomForest'){
return(AUC_RF)}
else
return(AUC)
if (set == 'predictions', method == 'randomForest'){
return(pred_RF)}
else
return (pred)
if (set == 'model', method=='randomForest'){
return(model_forest)}
else
return(model)
}
set.seed(123)
data_x = read.csv("credit.csv")
## Preprocessing the dataset
data_x$default <- ifelse(data_x$default == "yes", 1, 0)
## split the dataset
get_dataset<- function(x, split_ratio = 0.8, set = 'train'){
if (set == 'train'){
n <- nrow(data_x)
shuffled <- data_x[sample(n),]
# Split the data in train and test
train <- shuffled[1:round(split_ratio * n),]
test <- shuffled[(round(split_ratio * n) + 1):n,]
return(train)
}
if(set == 'test'){
n <- nrow(data_x)
shuffled <- data_x[sample(n),]
# Split the data in train and test
train <- shuffled[1:round(split_ratio * n),]
test <- shuffled[(round(split_ratio * n) + 1):n,]
return(test)
}
else
return (NULL)
}
train = get_dataset(data_x, set = 'train')
nrow(train)
test= get_dataset(data_x, set = 'test')
nrow(test)
pacman::p_load(shiny,shinydashboard,gbm, randomForest,ggplot2,ipred,caret,ROCR,dplyr,ModelMetrics)
model = function(algo =gbm ,distribution = 'bernoulli',
type = 'response', set='AUC',n.trees=10000){
## Fit the model
model<- algo(formula = default ~ .,
distribution = distribution,
data = train,
n.trees = n.trees,
cv.fold= 3)
## Generate the prediction on the test set
pred<- predict(object = model,
newdata = test,
n.trees = n.trees,
type = type)
## Generate the test set AUCs using the pred
AUC<- auc(actual = test$default, predicted = pred)
if (set == 'AUC'){
return(AUC)
}
if (set == 'predictions'){
return(pred)
}
if (set == 'model'){
return(model)
}
else
return(NULL)
}
get_auc= function(algo, type,n.trees){
z = model(algo = algo,type = type, set = 'AUC')
}
GBM_auc = get_auc(algo = gbm, type='response',method='gbm')
GBM_auc = get_auc(algo = gbm, type='response')
GBM_auc
RF_auc = map(as.factor(train$default),get_auc(randomForest, type ='response'))
library(purrr)
RF_auc = map(as.factor(train$default),get_auc(randomForest, type ='response'))
RF_auc
rm(RF_AUC)
RF_auc =  get_auc(algo = randomForest, type ='response')
RF_auc
BAG_auc = get_auc(algo = bagging, type ='class')
BAG_auc
GBM_auc
RF_auc
BAG_auc
get_pred<- function(algo, type, n.trees =10000){
z= model(algo = algo, type= type, set = 'predictions')
}
BAG_preds<- get_pred(algo = bagging, type= 'class')
RF_pred<- get_pred(algo = randomForest, type ='response')
GBM_pred<- get_pred(algo = gbm, type = 'response')
pred_list<-list(BAG_preds,RF_pred, GBM_pred)
get_model<- function(algo,type = 'response', ntrees = 10000){
z= model(algo = algo, type= type, set = 'model')
}
Bag_model<- get_model(algo = bagging, type='prob')
RF_model<- get_model(algo = randomForest)
GBM_model<- get_model(algo = gbm)
get_ROC = function(pred_list, actual = test$default, legend){
pred<-prediction(pred_list, actual)
roc<-performance(pred,"tpr","fpr")
plot(roc, main = "Test Set ROC Curves")
legend(x = "bottomright",
legend = legend)
}
pred <- prediction(pred_list, actual_list)
roc <- performance(pred, "tpr", "fpr")
plot(roc, col = as.list(1:m), main = "Test Set ROC Curves")
legend(x = "bottomright",
legend = c("Bagged Trees", "Random Forest", "GBM"),
fill = 1:m)
m<-length(pred_list)
actual_list<-rep(list(test$default),m)
pred <- prediction(pred_list, actual_list)
roc <- performance(pred, "tpr", "fpr")
plot(roc, col = as.list(1:m), main = "Test Set ROC Curves")
legend(x = "bottomright",
legend = c("Bagged Trees", "Random Forest", "GBM"),
fill = 1:m)
model_rf<-randomForest(train_rf$default ~ .,
data = train_rf,
distribution ='bernoulli',
mtry = optimal_grid_options[[1]],
nodesize = hyper_grid$nodesize[[2]],
sampsize = hyper_grid$sampsize[[3]],
ntrees = 10000)
predict_opt<-predict(object = model,
newdata = test_rf,
n.trees = 10000,
type = 'response')
runApp('~/Ensemble.UI')
library(shiny)
ui<- shinyUI(fluidPage(
fluidRow(
column(1),
column(
width = 10,
# Application title
titlePanel("Directory Input Demo"),
directoryInput('directory', label = 'selected directory', value = '~'),
tags$h5('Files'),
dataTableOutput('files')
),
column(1)
)
))
library(shiny)
server<-shinyServer(function(input, output, session) {
observeEvent(
ignoreNULL = TRUE,
eventExpr = {
input$directory
},
handlerExpr = {
if (input$directory > 0) {
# condition prevents handler execution on initial app launch
path = choose.dir(default = readDirectoryInput(session, 'directory'))
updateDirectoryInput(session, 'directory', value = path)
}
}
)
output$directory = renderText({
readDirectoryInput(session, 'directory')
})
output$files = renderDataTable({
files = list.files(readDirectoryInput(session, 'directory'), full.names = T)
data.frame(name = basename(files), file.info(files))
})
})
# Create a Shiny app object
shinyApp(ui = ui, server = server)
library(shiny)
ui<- shinyUI(fluidPage(
fluidRow(
column(1),
column(
width = 10,
# Application title
titlePanel("Directory Input Demo"),
directoryInput('directory', label = 'selected directory', value = '~'),
tags$h5('Files'),
dataTableOutput('files')
),
column(1)
)
))
ui<- shinyUI(fluidPage(
fluidRow(
column(1),
column(
width = 10,
# Application title
titlePanel("Directory Input Demo"),
directoryInput('directory', label = 'selected directory', value = '~'),
tags$h5('Files'),
dataTableOutput('files')
),
column(1)
)
))
install.packages("shinyfiles")
install.packages("shinyFiles")
library(shinyFiles)
library(shinyFiles)
ui<- shinyUI(fluidPage(sidebarLayout(
sidebarPanel(
shinyDirButton("dir", "Chose directory", "Upload")
),
mainPanel(
h4("output$dir"),
verbatimTextOutput("dir"), br(),
h4("Files in that dir"),
verbatimTextOutput("files")
)
)))
# files
output$files <- renderPrint(list.files(path()))
server<-shinyServer(function(input, output, session) {
# dir
shinyDirChoose(input, 'dir', roots = c(home = '~'), filetypes = c('', 'txt'))
dir <- reactive(input$dir)
output$dir <- renderPrint(dir())
# path
path <- reactive({
home <- normalizePath("~")
file.path(home, paste(unlist(dir()$path[-1]), collapse = .Platform$file.sep))
})
# files
output$files <- renderPrint(list.files(path()))
# Create a Shiny app object
shinyApp(ui = ui, server = server)
server<-shinyServer(function(input, output, session) {
# dir
shinyDirChoose(input, 'dir', roots = c(home = '~'), filetypes = c('', 'txt'))
dir <- reactive(input$dir)
output$dir <- renderPrint(dir())
# path
path <- reactive({
home <- normalizePath("~")
file.path(home, paste(unlist(dir()$path[-1]), collapse = .Platform$file.sep))
})
# files
output$files <- renderPrint(list.files(path()))
server<-shinyServer(function(input, output, session) {
# dir
shinyDirChoose(input, 'dir', roots = c(home = '~'), filetypes = c('', 'txt'))
dir <- reactive(input$dir)
output$dir <- renderPrint(dir())
# path
path <- reactive({
home <- normalizePath("~")
file.path(home, paste(unlist(dir()$path[-1]), collapse = .Platform$file.sep))
})
# files
output$files <- renderPrint(list.files(path()))
})
server<-shinyServer(function(input, output, session) {
# dir
shinyDirChoose(input, 'dir', roots = c(home = '~'), filetypes = c('', 'txt'))
dir <- reactive(input$dir)
output$dir <- renderPrint(dir())
# path
path <- reactive({
home <- normalizePath("~")
file.path(home, paste(unlist(dir()$path[-1]), collapse = .Platform$file.sep))
})
# files
output$files <- renderPrint(list.files(path()))
})
server<-shinyServer(function(input, output, session) {
# dir
shinyDirChoose(input, 'dir', roots = c(home = '~'), filetypes = c('', 'txt'))
dir <- reactive(input$dir)
output$dir <- renderPrint(dir())
# path
path <- reactive({
home <- normalizePath("~")
file.path(home, paste(unlist(dir()$path[-1]), collapse = .Platform$file.sep))
})
# files
output$files <- renderPrint(list.files(path()))
})
shinyApp(ui = ui, server = server)
?`shinyFiles-buttons`
runApp('D:/Documents/R_Projects/Data_Camp_Tutorials/ShinyDashboard/IMDB/dateInput_UI.R')
