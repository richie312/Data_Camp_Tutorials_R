---
title: "Introducing Purrr"
output: html_notebook
---

# Introducing purrr package

```{r}
##There is one function for each type of vector

map() ## returns a list

map_dbl() # returns a double vector

map_lgl() # returns a logical vector

map_int() # returns a integer vector

map_chr() # returns a character vector 

```

## Map Functions

```{r, eval = FALSE}

# Load the purrr package
library(purrr)

# Use map_dbl() to find column means
 map_dbl(df, mean)

# Use map_dbl() to column medians
map_dbl(df, median)

# Use map_dbl() to find column standard deviations
map_dbl(df, sd)


# Find the mean of each column
map_dbl(planes, mean)

# Find the mean of each column, excluding missing values
map_dbl(planes, mean,na.rm = TRUE)

# Find the 5th percentile of each column, excluding missing values
map_dbl(planes, quantile, prob = 0.05,na.rm = TRUE)

# Find the mean of each column
map_dbl(planes, mean)

# Find the mean of each column, excluding missing values
map_dbl(planes, mean,na.rm = TRUE)

# Find the 5th percentile of each column, excluding missing values
map_dbl(planes, quantile, prob = 0.05,na.rm = TRUE)



```

## Picking the right map function

```{r,eval = FALSE}

# Find the columns that are numeric
map_lgl(df3, is.numeric)


# Find the type of each column
map_chr(df3,typeof)

# Find a summary of each column
map(df3, summary)

```

### Shortcuts: Anonymous function created on the fly


```{r, eval = FALSE}

map(df, function(x)sum(is.na(x)))

```

### An anonymous function defined using a formula shortcut

```{r, eval = FALSE}

map(df,~sum(is.na(.)))

```


### Shortcuts when .f [[

```{r, eval = FALSE}
library(purrr)

list_of_results <- list(
  list(a=1, b="A"),
  list(a=2, b="C"),
  list(a = 3, b="C")
)

map_dbl(list_of_results, function(x) x[["a"]])  ## An anonymous function

map_dbl(list_of_results, "a") ## Shortcut: string Subsetting

map_dbl(list_of_results, 1) ## Shortcut integer subsetting

```

## Solve a simple problem first

```{r, eval = FALSE}

# Examine the structure of cyl

str(cyl)

# Extract the first element into four_cyls

four_cyls<-cyl[["4"]]

  # Fit a linear regression of mpg on wt using four_cyls
lm(mpg~wt,four_cyls)

```

## Short cut " . " for anonymous function

```{r, eval = FALSE}

map(cyl, ~lm(mpg ~ wt, data = .))

```


## Using a formula

```{r, eval = FALSE}

map(cyl, ~ lm(mpg ~ wt, data = .))

# Save the result from the previous exercise to the variable models
models<- map(cyl, ~ lm(mpg ~ wt, data = .))

# Use map and coef to get the coefficients for each model: coefs

coefs<- map(models,~coef(.))

# Use string shortcut to extract the wt coefficient 

map(models, "wt")

```



## USing a nmeric Vector

```{r, eval = FALSE}

# use map_dbl with the numeric shortcut to pull out the second element

map_dbl(coefs, 2)

```


## Putting it together with pipes ## %>% operator


```{r,eval = FALSE}

# Define models (don't change)
models <- mtcars %>% 
  split(mtcars$cyl) %>%
  map(~ lm(mpg ~ wt, data = .))

# Rewrite to be a single command using pipes 
summaries <- models%>%map(summary)
summaries%>%map_dbl("r.squared")
```






























































































































